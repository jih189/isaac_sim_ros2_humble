// /***
//     Randomly generate a set of joint values and pass them to the kin_forward function.
//     Then, we use the RobotState object to get the link poses and compare them with the link poses generated by the kin_forward function.
//  */
// void TEST_KINE_FORWARD(const moveit::core::RobotModelPtr & robot_model, const std::string & group_name, rclcpp::Node::SharedPtr node, bool debug = false){

//     std::cout << "TEST kine_forward with robot model " << robot_model->getName() << std::endl;

//     std::string collision_spheres_file_path;
//     node->get_parameter("collision_spheres_file_path", collision_spheres_file_path);
//     RCLCPP_INFO(LOGGER, "collision_spheres_file_path: %s", collision_spheres_file_path.c_str());

//     moveit::core::RobotStatePtr robot_state = std::make_shared<moveit::core::RobotState>(robot_model);
//     // set robot state to default state
//     robot_state->setToDefaultValues();
//     const std::vector<std::string>& joint_names = robot_model->getActiveJointModelNames();

//     // Generate test set
//     std::vector<std::vector<float>> joint_values_test_set;
//     for (size_t t = 0; t < 20; t++)
//     {
//         // Generate sampled configuration
//         robot_state->setToRandomPositions();
//         robot_state->update(); 

//         std::vector<float> sampled_joint_values;
//         for (const auto& joint_name : joint_names)
//         {
//             sampled_joint_values.push_back((float)(robot_state->getJointPositions(joint_name)[0]));
//         }

//         joint_values_test_set.push_back(sampled_joint_values);
//     }

//     // Get robot information
//     RobotInfo robot_info(robot_model, group_name, collision_spheres_file_path, debug);

//     std::vector<std::vector<Eigen::Isometry3d>> link_poses_from_kin_forward;
//     // std::vector<std::vector<Eigen::Isometry3d>> link_poses_from_kin_forward_cuda;
//     // CUDAMPLib::kin_forward(
//     //     joint_values_test_set,
//     //     robot_info.getJointTypes(),
//     //     robot_info.getJointPoses(),
//     //     robot_info.getJointAxes(),
//     //     robot_info.getLinkMaps(),
//     //     link_poses_from_kin_forward
//     // );

//     // test cuda
//     CUDAMPLib::kin_forward_cuda(
//         joint_values_test_set,
//         robot_info.getJointTypes(),
//         robot_info.getJointPoses(),
//         robot_info.getJointAxes(),
//         robot_info.getLinkMaps(),
//         link_poses_from_kin_forward
//     );

//     // print link poses
//     for (size_t i = 0; i < link_poses_from_kin_forward.size(); i++)
//     {
//         std::cout << "Test Set " << i << " with joint configuration: ";
//         // compute link poses from robot state
//         for (size_t j = 0; j < joint_names.size(); j++)
//         {
//             std::cout << " " << joint_values_test_set[i][j];
//             robot_state->setJointPositions(joint_names[j], std::vector<double>{(double)joint_values_test_set[i][j]});
//         }
//         std::cout << std::endl;
//         robot_state->update();

//         bool equal = true;

//         for (size_t j = 0; j < link_poses_from_kin_forward[i].size(); j++)
//         {
//             const Eigen::Isometry3d& link_pose_from_robot_state = robot_state->getGlobalLinkTransform(robot_info.getLinkNames()[j]);

//             if (debug)
//             {
//                 std::cout << "link name: " << robot_info.getLinkNames()[j] << std::endl;
//                 std::cout << "link pose from kin_forward: " << std::endl;
//                 std::cout << link_poses_from_kin_forward[i][j].matrix() << std::endl;
//                 std::cout << "link pose from robot state: " << std::endl;
//                 std::cout << link_pose_from_robot_state.matrix() << std::endl;
//             }

//             // if (link_poses_from_kin_forward[i][j].isApprox(link_pose_from_robot_state, 1e-4))
//             // {
//             //     // print above text with green color
//             //     // std::cout << "\033[1;32mLink " << robot_info.getLinkNames()[j] << " poses are equal\033[0m" << std::endl;
//             // }
//             // else
//             if (not link_poses_from_kin_forward[i][j].isApprox(link_pose_from_robot_state, 1e-4))
//             {
//                 // print parent link
//                 const moveit::core::LinkModel* link_model = robot_model->getLinkModel(robot_info.getLinkNames()[j]);
//                 std::string parent_link_name = link_model->getParentLinkModel()->getName();
//                 std::cout << "Parent Link name: " << parent_link_name << std::endl;
//                 // print joint name
//                 const moveit::core::JointModel* joint_model = link_model->getParentJointModel();
//                 std::cout << "Joint name: " << joint_model->getName() << std::endl;
//                 std::cout << "Joint type: " << joint_model->getType() << std::endl;
//                 std::cout << "Joint value: " << joint_values_test_set[i][j] << std::endl;
//                 std::cout << "parent pose: " << std::endl;
//                 std::cout << link_poses_from_kin_forward[i][robot_info.getLinkMaps()[j]].matrix() << std::endl;
//                 std::cout << "joint pose: " << std::endl;
//                 std::cout << robot_info.getJointPoses()[j].matrix() << std::endl;
//                 std::cout << "joint axis: " << std::endl;
//                 std::cout << robot_info.getJointAxes()[j].transpose() << std::endl;

//                 // print above text with red color
//                 std::cout << "\033[1;31mLink " << robot_info.getLinkNames()[j] << " poses are not equal\033[0m" << std::endl;
                
//                 equal = false;
//                 break;
//             }
//         }

//         if (equal)
//         {
//             std::cout << "\033[1;32m Task pass \033[0m" << std::endl;
//         }
//         else
//         {
//             std::cout << "\033[1;31m Task fail \033[0m" << std::endl;
//         }
//     }

//     robot_state.reset();
// }

// /***
//     Randomly generate a joint configuration and pass it to the kin_forward_collision_spheres_cuda function.
//     This function will return the collision spheres positions in base_link frame, then we will 
//     visualize the collision spheres in rviz.
//  */
// void DISPLAY_ROBOT_STATE_IN_RVIZ(const moveit::core::RobotModelPtr & robot_model, const std::string & group_name, rclcpp::Node::SharedPtr node, bool debug = false)
// {

//     std::string collision_spheres_file_path;
//     node->get_parameter("collision_spheres_file_path", collision_spheres_file_path);
//     RCLCPP_INFO(LOGGER, "collision_spheres_file_path: %s", collision_spheres_file_path.c_str());

//     RobotInfo robot_info(robot_model, group_name, collision_spheres_file_path, debug);

//     moveit::core::RobotStatePtr robot_state = std::make_shared<moveit::core::RobotState>(robot_model);
//     // set robot state to default state
//     robot_state->setToDefaultValues();
//     const std::vector<std::string>& joint_names = robot_model->getActiveJointModelNames();

//     // print robot model name
//     RCLCPP_INFO(LOGGER, "Robot model name: %s", robot_model->getName().c_str());

//     // random set joint values
//     robot_state->setToRandomPositions();
//     robot_state->update();

//     // Generate test set with one configuration.
//     std::vector<std::vector<float>> joint_values_test_set;
//     std::vector<float> sampled_joint_values;
//     for (const auto& joint_name : joint_names)
//     {
//         sampled_joint_values.push_back((float)(robot_state->getJointPositions(joint_name)[0]));
//     }
//     joint_values_test_set.push_back(sampled_joint_values);

//     std::vector<std::vector<Eigen::Isometry3d>> link_poses_from_kin_forward;
//     std::vector<std::vector<std::vector<float>>> collision_spheres_pos_from_kin_forward;

//     // test cuda
//     CUDAMPLib::kin_forward_collision_spheres_cuda(
//         joint_values_test_set,
//         robot_info.getJointTypes(),
//         robot_info.getJointPoses(),
//         robot_info.getJointAxes(),
//         robot_info.getLinkMaps(),
//         robot_info.getCollisionSpheresMap(),
//         robot_info.getCollisionSpheresPos(),
//         link_poses_from_kin_forward,
//         collision_spheres_pos_from_kin_forward
//     );

//     std::vector<std::vector<float>> collision_spheres_pos_of_first_config;
//     for (const auto & collision_spheres_in_link : collision_spheres_pos_from_kin_forward[0])
//     {
//         for (size_t i = 0; i < collision_spheres_in_link.size(); i += 3)
//         {
//             collision_spheres_pos_of_first_config.push_back({collision_spheres_in_link[i], collision_spheres_in_link[i + 1], collision_spheres_in_link[i + 2]});
//             // std::cout << "cs pos: " << collision_spheres_in_link[i] << " " << collision_spheres_in_link[i + 1] << " " << collision_spheres_in_link[i + 2] << " radius " << robot_info.getCollisionSpheresRadius()[i] << std::endl;
//         }
//     }

//     // Create marker publisher
//     auto marker_publisher = node->create_publisher<visualization_msgs::msg::MarkerArray>("collision_spheres", 1);

//     // Create a MarkerArray message
//     visualization_msgs::msg::MarkerArray robot_collision_spheres_marker_array = generate_self_collision_markers(collision_spheres_pos_of_first_config, robot_info.getCollisionSpheresRadius(), node);
//     // Create a robot state publisher
//     auto robot_state_publisher = node->create_publisher<moveit_msgs::msg::DisplayRobotState>("display_robot_state", 1);

//     // Create a DisplayRobotState message
//     moveit_msgs::msg::DisplayRobotState display_robot_state;
//     moveit::core::robotStateToRobotStateMsg(*robot_state, display_robot_state.state);

//     // use loop to publish the trajectory
//     while (rclcpp::ok())
//     {
//         // Publish the message
//         robot_state_publisher->publish(display_robot_state);
//         marker_publisher->publish(robot_collision_spheres_marker_array);
        
//         rclcpp::spin_some(node);

//         // sleep for 1 second
//         std::this_thread::sleep_for(std::chrono::seconds(1));
//     }

//     robot_state.reset();
// }

// /***
//     Testing collision
//     Here is the steps:
//     1. Randomly generate some balls in base_link frame.
//     2. Sample an arm configuration and pass it to kin_forward_collision_spheres_cuda function.
//     3. Check self collision.
//     4. Check collision with the balls.
//     5. Visualize the balls with different color based on collision reasons(self collision or env collision).
//  */
// void TEST_COLLISIONS(const moveit::core::RobotModelPtr & robot_model, const std::string & group_name, rclcpp::Node::SharedPtr node, bool debug = false)
// {

//     std::string collision_spheres_file_path;
//     node->get_parameter("collision_spheres_file_path", collision_spheres_file_path);
//     RCLCPP_INFO(LOGGER, "collision_spheres_file_path: %s", collision_spheres_file_path.c_str());

//     RobotInfo robot_info(robot_model, group_name, collision_spheres_file_path, debug);

//     moveit::core::RobotStatePtr robot_state = std::make_shared<moveit::core::RobotState>(robot_model);
//     // set robot state to default state
//     robot_state->setToDefaultValues();
//     const std::vector<std::string>& joint_names = robot_model->getActiveJointModelNames();

//     // print robot model name
//     RCLCPP_INFO(LOGGER, "Robot model name: %s", robot_model->getName().c_str());

//     // // random set joint values
//     // robot_state->setToRandomPositions();
//     // robot_state->update();

//     std::vector<std::vector<float>> balls_pos;
//     std::vector<float> ball_radius;
//     prepare_obstacles(balls_pos, ball_radius);

//     // Generate test set with one configuration.
//     std::vector<std::vector<float>> joint_values_test_set;

//     int num_of_sampled_configurations = 100;

//     for (int t = 0; t < num_of_sampled_configurations; t++)
//     {
//         // Generate sampled configuration
//         robot_state->setToRandomPositions();
//         robot_state->update();

//         std::vector<float> sampled_joint_values;
//         for (const auto& joint_name : joint_names)
//         {
//             sampled_joint_values.push_back((float)(robot_state->getJointPositions(joint_name)[0]));
//         }
//         joint_values_test_set.push_back(sampled_joint_values);
//     }

//     // create collision cost as a shared pointer
//     CUDAMPLib::CollisionCostPtr collision_cost = std::make_shared<CUDAMPLib::CollisionCost>(
//         balls_pos,
//         ball_radius
//     );
//     // create self collision cost as a shared pointer
//     CUDAMPLib::SelfCollisionCostPtr self_collision_cost = std::make_shared<CUDAMPLib::SelfCollisionCost>(
//         robot_info.getCollisionSpheresMap(),
//         robot_info.getSelfCollisionEnabledMap()
//     );

//     std::vector<CUDAMPLib::CostBasePtr> cost_set;
//     std::vector<float> cost_of_configurations;
//     cost_set.push_back(collision_cost);
//     cost_set.push_back(self_collision_cost);
//     std::vector<std::vector<std::vector<float>>> collision_spheres_pos_in_base_link_for_debug;

//     CUDAMPLib::evaluation_cuda(
//         joint_values_test_set,
//         robot_info.getJointTypes(),
//         robot_info.getJointPoses(),
//         robot_info.getJointAxes(),
//         robot_info.getLinkMaps(),
//         robot_info.getCollisionSpheresMap(),
//         robot_info.getCollisionSpheresPos(),
//         robot_info.getCollisionSpheresRadius(),
//         cost_set,
//         cost_of_configurations,
//         collision_spheres_pos_in_base_link_for_debug
//     );

//     int collision_free_configuration_index = -1;
//     for (int i = 0; i < num_of_sampled_configurations; i++)
//     {
//         if (cost_of_configurations[i] == 0.0)
//         {
//             collision_free_configuration_index = i;
//             break;
//         }
//     }

//     if (collision_free_configuration_index == -1)
//     {
//         std::cout << "=========================No collision free configuration==============================" << std::endl;
//         collision_free_configuration_index = 0;
//         std::cout << "cost of the first configuration: " << cost_of_configurations[0] << std::endl;
//     }

//     std::vector<std::vector<float>> collision_spheres_pos_of_selected_config;
//     for (const auto & collision_spheres_in_link : collision_spheres_pos_in_base_link_for_debug[collision_free_configuration_index])
//     {
//         for (size_t i = 0; i < collision_spheres_in_link.size(); i += 3)
//         {
//             collision_spheres_pos_of_selected_config.push_back({collision_spheres_in_link[i], collision_spheres_in_link[i + 1], collision_spheres_in_link[i + 2]});
//         }
//     }

//     // set the robot state to the collision free configuration
//     for (size_t j = 0; j < joint_names.size(); j++)
//     {
//         robot_state->setJointPositions(joint_names[j], std::vector<double>{(double)joint_values_test_set[collision_free_configuration_index][j]});
//     }
//     robot_state->update();

//     // print collision_free_configuration_index
//     std::cout << "collision_free_configuration_index: " << collision_free_configuration_index << std::endl;

//     /********************************************** */

//     // Create marker publisher
//     auto obstacle_marker_publisher = node->create_publisher<visualization_msgs::msg::MarkerArray>("obstacle_collision_spheres", 1);

//     // Create a robot state publisher
//     auto robot_state_publisher = node->create_publisher<moveit_msgs::msg::DisplayRobotState>("display_robot_state", 1);

//     // Create marker publisher
//     auto self_marker_publisher = node->create_publisher<visualization_msgs::msg::MarkerArray>("self_collision_spheres", 1);

//     // Create a DisplayRobotState message
//     moveit_msgs::msg::DisplayRobotState display_robot_state;
//     moveit::core::robotStateToRobotStateMsg(*robot_state, display_robot_state.state);

//     // Create a self MarkerArray message
//     visualization_msgs::msg::MarkerArray robot_collision_spheres_marker_array = generate_self_collision_markers(
//         collision_spheres_pos_of_selected_config,
//         robot_info.getCollisionSpheresRadius(),
//         node
//     );

//     // Create a obstacle MarkerArray message
//     visualization_msgs::msg::MarkerArray obstacle_collision_spheres_marker_array = generate_obstacles_markers(balls_pos, ball_radius, node);

//     // use loop to publish the trajectory
//     while (rclcpp::ok())
//     {
//         // Publish the message
//         obstacle_marker_publisher->publish(obstacle_collision_spheres_marker_array);
//         self_marker_publisher->publish(robot_collision_spheres_marker_array);
//         robot_state_publisher->publish(display_robot_state);
        
//         rclcpp::spin_some(node);

//         // sleep for 1 second
//         std::this_thread::sleep_for(std::chrono::seconds(1));
//     }

//     robot_state.reset();
// }