#include <rclcpp/rclcpp.hpp>
#include <moveit/robot_model_loader/robot_model_loader.h>
#include <moveit/robot_model/robot_model.h>
#include <moveit/robot_state/robot_state.h>
#include <moveit/planning_pipeline/planning_pipeline.h>
#include "moveit/planning_interface/planning_interface.h"
#include "moveit/robot_state/conversions.h"
#include <moveit/kinematic_constraints/utils.h>
#include <moveit/planning_scene_monitor/planning_scene_monitor.h>

#include <CUDAMPLib/multiply.h>
#include <CUDAMPLib/kinematics.h>

static const rclcpp::Logger LOGGER = rclcpp::get_logger("CUDAMPLib");

/***
Randomly generate a set of joint values and pass them to the kin_forward function.
Then, we use the RobotState object to get the link poses and compare them with the link poses generated by the kin_forward function.
 */
void TEST_KINE_FORWARD(const moveit::core::RobotModelPtr & robot_model){

    std::cout << "TEST kine_forward with robot model " << robot_model->getName() << std::endl;

    moveit::core::RobotStatePtr robot_state = std::make_shared<moveit::core::RobotState>(robot_model);
    const std::vector<std::string>& joint_names = robot_model->getActiveJointModelNames();

    // // Set test joint values
    // for (const auto& joint_name : joint_names)
    // {
    //     robot_state->setJointPositions(joint_name, std::vector<double>{0.0});
    // }
    robot_state->setToRandomPositions();
    robot_state->update(); // call update to propagate the joint values to the kinematic model

    // Get the sampled joint values
    std::vector<float> sampled_joint_values;
    for (const auto& joint_name : joint_names)
    {
        sampled_joint_values.push_back((float)(robot_state->getJointPositions(joint_name)[0]));
    }

    // ready the joint values for testing
    std::vector<std::vector<float>> test_joint_values;
    test_joint_values.push_back(sampled_joint_values);

    // Ready the input to kin_forward
    std::vector<int> test_joint_types;
    std::vector<Eigen::Isometry3d> test_joint_poses;
    std::vector<Eigen::Vector3d> test_joint_axes;
    std::vector<int> test_link_maps;

    // Get all link names
    const std::vector<std::string>& link_names = robot_model->getLinkModelNames();
    // Ready the input to kin_forward
    for (const auto& link_name : link_names)
    {
        std::cout << "link name: " << link_name << std::endl;
        
        // print its parent link name
        const moveit::core::LinkModel* link_model = robot_model->getLinkModel(link_name);
        if (link_model->getParentLinkModel() != nullptr)
        {
            std::string parent_link_name = link_model->getParentLinkModel()->getName();
            std::cout << "Parent Link name: " << parent_link_name << std::endl;

            // find the index of parent_link_name in the link_names
            int parent_link_index = -1;
            for (size_t i = 0; i < link_names.size(); i++)
            {
                if (link_names[i] == parent_link_name)
                {
                    parent_link_index = i;
                    break;
                }
            }
            test_link_maps.push_back(parent_link_index);

            // find joint name to its parent link
            const moveit::core::JointModel* joint_model = link_model->getParentJointModel();
            std::cout << "Joint name: " << joint_model->getName() << std::endl;
            // print joint type
            std::cout << "Joint type: " << joint_model->getType() << std::endl;
            test_joint_types.push_back(joint_model->getType());

            if (joint_model->getType() == moveit::core::JointModel::REVOLUTE)
            {
                const moveit::core::RevoluteJointModel* revolute_joint_model = dynamic_cast<const moveit::core::RevoluteJointModel*>(joint_model);
                std::cout << "Joint axis: " << revolute_joint_model->getAxis().transpose() << std::endl;
                test_joint_axes.push_back(revolute_joint_model->getAxis());
            }
            else if (joint_model->getType() == moveit::core::JointModel::PRISMATIC)
            {
                const moveit::core::PrismaticJointModel* prismatic_joint_model = dynamic_cast<const moveit::core::PrismaticJointModel*>(joint_model);
                std::cout << "Joint axis: " << prismatic_joint_model->getAxis().transpose() << std::endl;
                test_joint_axes.push_back(prismatic_joint_model->getAxis());
            }

            // get joint origin transform
            test_joint_poses.push_back(link_model->getJointOriginTransform());
        }
        else
        {
            test_joint_types.push_back(0); // 0 means unknown joint type
            test_joint_poses.push_back(Eigen::Isometry3d::Identity());
            test_joint_axes.push_back(Eigen::Vector3d::Zero());
            test_link_maps.push_back(-1);
        }
        std::cout << " ===================================== " << std::endl;
    }

    std::vector<std::vector<Eigen::Isometry3d>> link_poses_from_kin_forward;

    kin_forward(
        test_joint_values,
        test_joint_types,
        test_joint_poses,
        test_joint_axes,
        test_link_maps,
        link_poses_from_kin_forward
    );

    for (size_t i = 0; i < link_poses_from_kin_forward.size(); i++)
    {
        for (size_t j = 0; j < link_poses_from_kin_forward[i].size(); j++)
        {
            const Eigen::Isometry3d& link_pose = robot_state->getGlobalLinkTransform(link_names[j]);
            if (link_poses_from_kin_forward[i][j].isApprox(link_pose, 1e-4))
            {
                std::cout << "Link " << link_names[j] << " poses are equal" << std::endl;
            }
            else
            {
                std::cout << "Link " << link_names[j] << " poses are not equal" << std::endl;
                std::cout << "from kin_forward: " << std::endl;
                std::cout << link_poses_from_kin_forward[i][j].matrix() << std::endl;
                std::cout << "from robot state: " << std::endl;
                std::cout << link_pose.matrix() << std::endl;
            }
        }
    }

    // // print link poses
    // for (size_t i = 0; i < link_poses_from_kin_forward.size(); i++)
    // {
    //     std::cout << "Link Poses Set " << i << std::endl;
    //     for (size_t j = 0; j < link_poses_from_kin_forward[i].size(); j++)
    //     {
    //         std::cout << "link name: " << link_names[j] << std::endl;
    //         std::cout << link_poses_from_kin_forward[i][j].matrix() << std::endl;
    //     }
    // }

    // std::cout << "link poses:" << std::endl;
    // // print poses of each link
    // for (const auto& link_name : link_names)
    // {
    //     const Eigen::Isometry3d& link_pose = robot_state->getGlobalLinkTransform(link_name);
    //     std::cout << link_name << std::endl;
    //     std::cout << link_pose.matrix() << std::endl;
    // }
}

int main(int argc, char** argv)
{
    const std::string GROUP_NAME = "arm";

    rclcpp::init(argc, argv);
    rclcpp::NodeOptions node_options;
    node_options.automatically_declare_parameters_from_overrides(true);
    auto foliation_example_node = rclcpp::Node::make_shared("foliation_example_node", node_options);

    // print out the node name
    RCLCPP_INFO(LOGGER, "Node name: %s", foliation_example_node->get_name());

    // Create a robot model
    robot_model_loader::RobotModelLoaderPtr robot_model_loader(
      new robot_model_loader::RobotModelLoader(foliation_example_node, "robot_description"));
    const moveit::core::RobotModelPtr& kinematic_model = robot_model_loader->getModel();
    if (kinematic_model == nullptr)
    {
        RCLCPP_ERROR(foliation_example_node->get_logger(), "Failed to load robot model");
        return 1;
    }

    // Using the RobotModelLoader, we can construct a planning scene monitor that
    // will create a planning scene, monitors planning scene diffs, and apply the diffs to it's
    // internal planning scene. We then call startSceneMonitor, startWorldGeometryMonitor and
    // startStateMonitor to fully initialize the planning scene monitor
    planning_scene_monitor::PlanningSceneMonitorPtr psm(
        new planning_scene_monitor::PlanningSceneMonitor(foliation_example_node, robot_model_loader));

    /* listen for planning scene messages on topic /XXX and apply them to the internal planning scene
                       the internal planning scene accordingly */
    psm->startSceneMonitor();
    /* listens to changes of world geometry, collision objects, and (optionally) octomaps
                                    world geometry, collision objects and optionally octomaps */
    psm->startWorldGeometryMonitor();
    /* listen to joint state updates as well as changes in attached collision objects
                            and update the internal planning scene accordingly*/
    psm->startStateMonitor();

    // =========================================================================================

    TEST_KINE_FORWARD(kinematic_model);

    // stop the node
    rclcpp::shutdown();

    return 0;
}